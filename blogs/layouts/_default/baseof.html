{{/* this very goofy section gets the manifest in list for, then loops over it naming the keys and values then if the
cache-busted key name (which is the file name lol) contain our keyword controlled in hugo.toml and has the
corresponding suffix we add the import */}}

{{/* these are here as a fallback so that its still defined even though it wont work */}}
{{- $jspath := "default.js" -}}
{{- $importpaths := slice -}}
{{- $csspath := "default.js" -}}

{{- $blogkey := .Site.Params.blogkey -}}
{{- $csskey := .Site.Params.csskey -}}

{{- $manifest := readFile "/static/.vite/manifest.json" | transform.Unmarshal -}}
{{- range $key, $value := $manifest -}}

{{/* this weirdly needs to end in html since we are hooking into the blog-style index page to get the dependencies */}}
{{- if and (strings.Contains $key $blogkey) (strings.HasSuffix $key ".html") -}}
{{- $jspath = $value.file -}}
{{- $importpaths = $value.imports -}}
{{- else if and (strings.Contains $key $csskey) (strings.HasSuffix $key ".css") -}}
{{- $csspath = $value.file -}}
{{- end -}}

{{- end -}}

<!doctype html>
<html lang="en" data-type='{{- block "type" . -}}{{- end -}}'>

<head>
  {{- partial "head.html" . -}}
  <script type="module" crossorigin src="/{{ $jspath }}"></script>
  {{- range $i := seq (len $importpaths) -}}
  <link rel="modulepreload" crossorigin href='/assets/{{ strings.TrimPrefix "_" (index $importpaths (sub $i 1)) }}'>
  {{- end -}}
  <link rel="stylesheet" href="/{{ $csspath }}">
</head>

<body>
  <!-- <p>{{ $jspath }}</p> -->
  <!-- <p>{{ index $importpaths 0 }}</p> -->
  <!-- <p>{{ index $importpaths 1 }}</p> -->
  <!-- <p>{{ $csspath }}</p> -->

  <header>
    {{- partial "header.html" . -}}
  </header>

  <main>
    {{- block "main" . }}{{ end -}}
  </main>

  <footer>
    {{- block "linkstack" . }}{{ end -}}
    {{- partial "footer.html" . -}}
  </footer>
</body>

</html>
